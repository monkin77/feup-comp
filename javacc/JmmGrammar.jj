PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

SKIP : " " | "\t" | "\r" | "\n";

TOKEN :
    // Keywords
    < IMPORT : "import" > |
    < CLASS : "class" > |
    < EXTENDS : "extends" > |
    < PUBLIC : "public" > |
    < RETURN: "return" > |
    < STATIC: "static" > |
    < MAIN: "main" > |
    < IF: "if" > |
    < ELSE: "else" > |
    < WHILE: "while" > |
    < TRUE: "true" > |
    < FALSE: "false" > |
    < THIS: "this" > |
    < NEW: "new" > |

    // Types
    < VOID: "void" > |
    < STRING: "String" > |
    < INT: "int" > |
    < BOOL: "boolean" > |

    // Attributes
    < LENGTH: "length" > |

    // Operators
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< EQUALS : "=" > |
	< AND : "&&" > |
	< LESS: "<" > |
	< NOT: "!" > |

    // Parenthesis and alike
    < OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< OPEN_CURLY : "{" > |
	< CLOSE_CURLY : "}" > |
	< OPEN_SQUARE : "[" > |
	< CLOSE_SQUARE : "]" > |

    // Separators
	< SEMICOLON : ";" > |
	< DOT: "." > |
	< COMMA: "," > |

    // Clarification https://stackoverflow.com/questions/35578567/java-regex-for-identifiers-letters-digits-and-underscores
	< IDENTIFIER:
	    ( ( <LETTER> | <DOLLAR> ) ( <LETTER> | <DIGIT> | <UNDERSCORE> | <DOLLAR> )* ) |
	    ( <UNDERSCORE> ( <LETTER> | <DIGIT> | <UNDERSCORE> | <DOLLAR> )+ ) // Can't have identifier with single underscore
	> |

    // Symbols
    < INTEGER_LITERAL : ( <DIGIT> )+ > |
    < DIGIT: ["0"-"9"] > |
    < LETTER: ["a"-"z","A"-"Z"] > |
    < UNDERSCORE: "_" > |
    < DOLLAR: "$" >
;

Start : Program;

Program #void :
    ImportDeclaration ClassDeclaration <EOF>
;

ImportDeclaration #void :
    ( <IMPORT> <IDENTIFIER> ( <DOT> <IDENTIFIER> )* <SEMICOLON> )*
;

ClassDeclaration #void :
    <CLASS> <IDENTIFIER> [ <EXTENDS> <IDENTIFIER> ] <OPEN_CURLY>
        ( VarDeclaration )*
        ( MethodDeclaration )*
    <CLOSE_CURLY>
;

VarDeclarations #void :
    ( SCAN 2 ( VarDeclaration ) )*
;

VarDeclaration #void :
    Type <IDENTIFIER> <SEMICOLON>
;

MethodDeclaration #void :
    <PUBLIC> ( PublicMethodDeclaration | MainDeclaration )
;

PublicMethodDeclaration #void :
    Type <IDENTIFIER> <OPEN_PAREN>
        [ Type <IDENTIFIER> ( <COMMA> Type <IDENTIFIER> )* ]
    <CLOSE_PAREN> <OPEN_CURLY>
        VarDeclarations
        ( Statement )*
        <RETURN> Expression <SEMICOLON>
    <CLOSE_CURLY>
;

MainDeclaration #void :
    <STATIC> <VOID> <MAIN> <OPEN_PAREN>
        <STRING> <OPEN_SQUARE> <CLOSE_SQUARE> <IDENTIFIER>
    <CLOSE_PAREN> <OPEN_CURLY>
        VarDeclarations
        ( Statement )*
    <CLOSE_CURLY>
;

Type #void :
    <INT> <OPEN_SQUARE> <CLOSE_SQUARE> |
    <BOOL> |
    <INT> |
    <IDENTIFIER>
;

Statement #void :
    ( <OPEN_CURLY> ( Statement )* <CLOSE_CURLY> ) |
    ( <IF> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement <ELSE> Statement ) |
    ( <WHILE> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement ) |
    Assignment <SEMICOLON> | // TODO distinction between a[2] = 2; and a[2];
    ( Expression <SEMICOLON> )
;

Expression #void :
    AndExpression
;

AndExpression #void :
    LessExpression (<AND> LessExpression)*
;

LessExpression #void :
    ArithmeticExpression (<LESS> ArithmeticExpression)*
;

ArithmeticExpression #void :
    MultiplicativeExpression ( (<PLUS> | <MINUS>) MultiplicativeExpression )*
;

MultiplicativeExpression #void :
    NotExpression ( ( <TIMES> | <DIVIDE> ) NotExpression)*
;

// TODO verify this
NotExpression #void :
    ( <NOT> )* DotArrayExpression
;

DotArrayExpression #void :
    ExpressionTerminal ( DotExpression | ArrayExpression ) *
;

DotExpression #void :
    <DOT> ( <LENGTH> | DotMethod )
;

DotMethod #void :
    <IDENTIFIER> <OPEN_PAREN> [ Expression ( <COMMA> Expression )* ] <CLOSE_PAREN>
;

Assignment #void :
    IdOrArrayExpression <EQUALS> Expression
;

IdOrArrayExpression #void :
    SCAN 2 ( ArrayExpression | <IDENTIFIER> )
;

ArrayExpression #void :
    <IDENTIFIER> <OPEN_SQUARE> Expression <CLOSE_SQUARE>
;

NewExpression #void:
    <NEW> (
        NewArrayExpression |
        NewObjectExpression
    )
;

NewArrayExpression #void :
    <INT> <OPEN_SQUARE> Expression <CLOSE_SQUARE>
;

NewObjectExpression #void :
    <IDENTIFIER> <OPEN_PAREN> <CLOSE_PAREN>
;

ParenExpression #void :
    ( <OPEN_PAREN> Expression <CLOSE_PAREN> )
;

ExpressionTerminal #void :
    <INTEGER_LITERAL> |
    <TRUE> |
    <FALSE> |
    <IDENTIFIER> |
    <THIS> |
    ParenExpression |
    NewExpression
;
